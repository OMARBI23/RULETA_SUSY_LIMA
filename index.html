<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Ruletas Interactivas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a3a3a;
            color: #e5e7eb;
        }
        .roulette-container {
            transform-origin: center center;
        }
        .accent-green {
            color: #00ff99;
        }
        .form-input, .form-textarea {
            background-color: #1E3A44;
            border: 2px solid #00ff99;
            color: #e5e7eb;
        }
        .form-input:focus, .form-textarea:focus {
            outline: none;
            box-shadow: 0 0 10px #00ff99;
        }
        .main-btn {
             background-color: #00ff99;
             color: #1a3a3a;
             font-weight: bold;
             transition: all 0.3s ease;
        }
        .main-btn:hover {
            background-color: #fff;
            box-shadow: 0 0 15px #00ff99;
        }
        .delete-btn {
            background-color: #ef4444;
            color: white;
            border-radius: 9999px;
            width: 2rem;
            height: 2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .delete-btn:hover {
            background-color: #dc2626;
            transform: scale(1.1);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container mx-auto">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-bold text-white">Generador de Ruletas</h1>
            <p class="text-lg accent-green mt-2 font-semibold">Crea tus propias ruletas personalizadas</p>
        </header>

        <!-- Zona de Configuración -->
        <section id="setup-container" class="bg-[#1E3A44] p-6 rounded-2xl shadow-lg mb-8 max-w-4xl mx-auto">
            <div class="text-center mb-6">
                 <button id="add-roulette-btn" class="main-btn py-2 px-6 rounded-lg text-lg">Añadir Nueva Ruleta</button>
            </div>
            
            <div id="roulette-definitions" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Los campos para definir cada ruleta se insertarán aquí -->
            </div>

            <div id="generate-btn-container" class="text-center mt-8 hidden">
                <button id="generate-roulettes-btn" class="main-btn py-3 px-8 rounded-lg text-xl">¡Crear / Actualizar Ruletas!</button>
            </div>
        </section>

        <!-- Zona de Ruletas Generadas -->
        <main id="roulettes-display" class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Las ruletas generadas se mostrarán aquí -->
        </main>
    </div>

    <script>
        let audioCtx;
        let roulettesData = {};
        let definitionCounter = 0;

        // --- FUNCIONES DE SONIDO ---
        function playTickSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);
            oscillator.type = 'square'; oscillator.frequency.setValueAtTime(1200, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
            oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + 0.05);
        }

        function playWinSound() {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1046.50, audioCtx.currentTime + 0.15);
            gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
            oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + 0.4);
        }
        
        // --- LÓGICA DE LA INTERFAZ ---
        const addRouletteBtn = document.getElementById('add-roulette-btn');
        const generateRoulettesBtn = document.getElementById('generate-roulettes-btn');
        const definitionsContainer = document.getElementById('roulette-definitions');
        const generateBtnContainer = document.getElementById('generate-btn-container');
        
        function updateGenerateButtonVisibility() {
            const hasDefinitions = definitionsContainer.children.length > 0;
            generateBtnContainer.classList.toggle('hidden', !hasDefinitions);
        }

        addRouletteBtn.addEventListener('click', () => {
            definitionCounter++;
            const fieldHTML = `
                <div class="roulette-def-block bg-gray-800/20 p-4 rounded-lg relative" data-def-id="${definitionCounter}">
                    <button class="delete-btn absolute top-2 right-2 z-10" aria-label="Eliminar esta ruleta">X</button>
                    <h3 class="text-lg font-semibold mb-2 accent-green">Definición de Ruleta</h3>
                    <input type="text" placeholder="Título para la ruleta" class="form-input w-full p-2 rounded-md mb-2">
                    <textarea placeholder="Añade un participante por línea..." class="form-textarea w-full p-2 rounded-md h-32 resize-none"></textarea>
                </div>
            `;
            definitionsContainer.insertAdjacentHTML('beforeend', fieldHTML);
            updateGenerateButtonVisibility();
        });

        definitionsContainer.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-btn')) {
                const blockToRemove = event.target.closest('.roulette-def-block');
                if(blockToRemove) {
                    blockToRemove.remove();
                    updateGenerateButtonVisibility();
                }
            }
        });
        
        generateRoulettesBtn.addEventListener('click', () => {
            const displayContainer = document.getElementById('roulettes-display');
            displayContainer.innerHTML = '';
            roulettesData = {};

            const definitionBlocks = document.querySelectorAll('.roulette-def-block');
            definitionBlocks.forEach((block, index) => {
                const id = index + 1;
                const title = block.querySelector('input').value || `Ruleta ${id}`;
                const members = block.querySelector('textarea').value.split('\n').map(name => name.trim()).filter(name => name);

                if (members.length < 2) return;

                roulettesData[id] = {
                    title,
                    members,
                    colors: generateColors(members.length),
                    currentAngle: 0,
                    isSpinning: false,
                };

                const rouletteCardHTML = `
                    <div id="team-${id}" class="bg-[#1E3A44] p-6 rounded-2xl shadow-lg flex flex-col items-center">
                        <h2 class="text-2xl font-semibold mb-6 text-white text-center w-full truncate" title="${title}">${title}</h2>
                        <div class="relative w-72 h-72 md:w-80 md:h-80 mb-4">
                            <div id="roulette-container-${id}" class="roulette-container w-full h-full">
                                <canvas id="roulette-${id}" width="500" height="500" class="roulette-canvas rounded-full w-full h-full"></canvas>
                            </div>
                            <svg class="absolute top-[-12px] left-1/2 -translate-x-1/2 w-6 h-4 z-10" fill="#FFD700" viewBox="0 0 10 7"><polygon points="5,7 0,0 10,0"/></svg>
                        </div>
                        <button onclick="spinRoulette(${id})" class="w-full bg-[#00ff99] text-[#1a3a3a] font-bold py-3 px-6 rounded-lg hover:bg-opacity-90 transition duration-300 shadow-md text-lg">Girar Ruleta</button>
                        <div id="result-${id}" class="mt-4 text-center h-12 flex items-center justify-center">
                            <p class="text-lg font-semibold accent-green">&nbsp;</p>
                        </div>
                    </div>
                `;
                displayContainer.innerHTML += rouletteCardHTML;
            });

            Object.keys(roulettesData).forEach(id => drawRoulette(id));
            if(Object.keys(roulettesData).length > 0) {
                 displayContainer.scrollIntoView({ behavior: 'smooth' });
            }
        });

        // --- LÓGICA DE LA RULETA ---

        function generateColors(count) {
            const colors = [];
            const saturation = 85;
            const lightness = 65;
            const baseHue = Math.random() * 360; // Random starting point for unique colors per roulette
            for (let i = 0; i < count; i++) {
                const hue = Math.floor(baseHue + (i * 360) / count) % 360; // Offset each color from the base
                colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
            }
            return colors;
        }

        function drawRoulette(id) {
            const data = roulettesData[id];
            if (!data) return;
            const canvas = document.getElementById(`roulette-${id}`);
            if (!canvas.getContext) return;

            const ctx = canvas.getContext('2d');
            const numSegments = data.members.length;
            const angleStep = (2 * Math.PI) / numSegments;
            const radius = canvas.width / 2;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#1E3A44'; 
            ctx.lineWidth = 4; 

            data.members.forEach((member, i) => {
                const angle = i * angleStep;
                ctx.fillStyle = data.colors[i];
                ctx.beginPath(); ctx.moveTo(radius, radius);
                ctx.arc(radius, radius, radius - 5, angle - Math.PI / 2, angle + angleStep - Math.PI / 2);
                ctx.closePath(); ctx.fill(); ctx.stroke();
                
                ctx.save();
                ctx.fillStyle = '#fff';
                ctx.translate(radius, radius);
                ctx.rotate(angle + angleStep / 2 - Math.PI / 2);
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                // --- UPDATED: Font size is now responsive to the number of participants ---
                const maxBaseFontSize = 40; // Max font size for few participants
                const minBaseFontSize = 14; // Min font size for many participants
                // This formula creates a curve where font size decreases as participants increase.
                let initialFontSize = Math.max(minBaseFontSize, maxBaseFontSize - (numSegments * 1.5));
                let dynamicFontSize = Math.min(initialFontSize, radius * 0.1); 

                const minAbsFontSize = 12; // Absolute minimum readable font size
                const maxTextWidth = radius * 0.8; // Allow text to take up more space
                ctx.font = `bold ${dynamicFontSize}px Inter, sans-serif`;

                // Reduce font size further if a specific name is too long
                while (ctx.measureText(member).width > maxTextWidth && dynamicFontSize > minAbsFontSize) {
                    dynamicFontSize--;
                    ctx.font = `bold ${dynamicFontSize}px Inter, sans-serif`;
                }
                
                let displayName = member;
                // If text still doesn't fit, truncate it
                if (ctx.measureText(displayName).width > maxTextWidth) {
                    while (ctx.measureText(displayName + '...').width > maxTextWidth && displayName.length > 1) {
                        displayName = displayName.slice(0, -1);
                    }
                    displayName += '...';
                }

                ctx.fillText(displayName, radius - 20, 0); 
                ctx.restore();
            });
        }

        function spinRoulette(id) {
            const data = roulettesData[id];
            if (!data || data.isSpinning) return;
            data.isSpinning = true;

            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            const rouletteContainer = document.getElementById(`roulette-container-${id}`);
            const resultDiv = document.getElementById(`result-${id}`);
            resultDiv.querySelector('p').innerHTML = '&nbsp;';
            
            const randomDuration = 10 + Math.random() * 5; 
            const randomRotations = 10 + Math.random() * 10;
            
            rouletteContainer.style.transition = `transform ${randomDuration}s cubic-bezier(0.1, 0.9, 0.2, 1)`;

            const spinAngle = Math.random() * 360 + 360 * randomRotations;
            const newAngle = data.currentAngle + spinAngle;
            
            rouletteContainer.style.transform = `rotate(${newAngle}deg)`;
            data.currentAngle = newAngle;

            let lastKnownAngle = -1;
            const numSegments = data.members.length;
            const degreesPerSegment = 360 / numSegments;

            function tickLoop() {
                if (!data.isSpinning) return;
                const transformMatrix = window.getComputedStyle(rouletteContainer).transform;
                if (transformMatrix === 'none' || !transformMatrix.includes('(')) { 
                    requestAnimationFrame(tickLoop); 
                    return; 
                }
                const matrixValues = transformMatrix.split('(')[1].split(')')[0].split(',');
                const a = parseFloat(matrixValues[0]); const b = parseFloat(matrixValues[1]);
                const currentAngle = Math.round(Math.atan2(b, a) * (180 / Math.PI));
                const normalizedAngle = (currentAngle + 360) % 360;

                if (lastKnownAngle === -1) {
                    lastKnownAngle = normalizedAngle;
                }

                let angleTraveled = normalizedAngle - lastKnownAngle;

                if (angleTraveled < -270) { // Handle wrap-around from 359 to 0
                    angleTraveled += 360;
                } else if (angleTraveled > 270) { // Handle wrap-around from 0 to 359
                    angleTraveled -= 360;
                }

                if (angleTraveled > 0) {
                    const segmentsCrossed = Math.floor((lastKnownAngle + angleTraveled) / degreesPerSegment) - Math.floor(lastKnownAngle / degreesPerSegment);
                    
                    if (segmentsCrossed > 0) {
                        for (let i = 0; i < segmentsCrossed; i++) {
                           playTickSound();
                        }
                    }
                }
                
                lastKnownAngle = normalizedAngle;
                requestAnimationFrame(tickLoop);
            }
            requestAnimationFrame(tickLoop);

            setTimeout(() => {
                data.isSpinning = false;
                playWinSound(); 
                const finalAngle = data.currentAngle % 360;
                const winningAngle = 360 - finalAngle;
                const winnerIndex = Math.floor(winningAngle / degreesPerSegment);
                const winner = data.members[winnerIndex];
                resultDiv.querySelector('p').textContent = `¡El ganador es: ${winner}!`;
                rouletteContainer.style.transition = '';
            }, randomDuration * 1000); 
        }
    </script>
</body>
</html>

